---
layout: default
bottom_include: comments.html
include_comments:
  embed: true
  count: true
---

{% if page.header_image_path %}
<div class="post-header-image-container">
  <img src="{{ page.header_image_path }}" alt="{{ page.title }}" class="post-header-image">
</div>
{% endif %}

<article class="post">
  <button id="tts-button" aria-label="Listen to this post" title="Listen to this post" style="margin-bottom: 1em; padding: 0; cursor: pointer; width: 32px; height: 32px; border-radius: 50%; border: 2px solid #888; background: none; display: flex; align-items: center; justify-content: center; color: #888;">
    <!-- SVG Play Icon -->
    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
      <path d="M8 5v14l11-7z"/>
    </svg>
  </button>
  <div id="post-content-for-tts">
    {{ content }}
  </div>
  
  {% if page.image_credit %}
  <div class="image-credit-footer">
    <p><em>Header image: {{ page.image_credit }}</em></p>
  </div>
  {% endif %}
  
  <div class="mt4 mb4">{% include post-navigation.html %}</div>
  <div class="mt4">{% include author-share.html %}</div>
</article>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const ttsButton = document.getElementById('tts-button');
    const postContent = document.getElementById('post-content-for-tts');
    let isSpeaking = false;
    let utterance = null;
    let voices = [];
    let preferredVoice = null;
    let voicesLoaded = false; // Flag to track if voices are ready
    let keepAliveInterval = null; // Interval timer for keep-alive

    // Check if SpeechSynthesis is supported
    if (!('speechSynthesis' in window)) {
      console.warn('Speech Synthesis not supported in this browser.');
      if (ttsButton) {
        ttsButton.style.display = 'none'; // Hide button if not supported
      }
      return; 
    }

    // Function to populate voices and select a preferred one
    function populateAndSelectVoice() {
      voices = speechSynthesis.getVoices();
      if (voices.length > 0) {
          voicesLoaded = true; // Set flag only when voices are actually available
          console.log("Available voices:", voices); 
      } else {
          console.warn("getVoices() returned empty list.");
          return; // Don't proceed with selection if no voices
      }
      
      // --- Voice Selection Logic ---
      // Try to find a high-quality, non-local English voice first
      preferredVoice = voices.find(voice => 
        !voice.localService && voice.lang.startsWith('en') && /Google|Microsoft|Enhanced|Premium/i.test(voice.name)
      );

      // If no premium voice found, try any non-local English voice
      if (!preferredVoice) {
        preferredVoice = voices.find(voice => !voice.localService && voice.lang.startsWith('en'));
      }

      // If still no voice, try any English voice
      if (!preferredVoice) {
        preferredVoice = voices.find(voice => voice.lang.startsWith('en'));
      }
      
      // Fallback to the first available voice if no English one is found
      if (!preferredVoice && voices.length > 0) {
          preferredVoice = voices[0];
      }

      if (preferredVoice) {
        console.log("Selected voice:", preferredVoice.name, `(${preferredVoice.lang})`);
      } else {
        console.warn("Could not find a preferred voice, using browser default.");
      }
      // --- End Voice Selection Logic ---
      
      // Start keep-alive once voices are loaded
      if (voicesLoaded && !keepAliveInterval) {
          startKeepAlive();
      }
    }

    // Function to start the keep-alive interval
    function startKeepAlive() {
        if (keepAliveInterval) return; // Already running
        console.log("Starting keep-alive interval.");
        keepAliveInterval = setInterval(() => {
            if (!isSpeaking && !speechSynthesis.speaking) {
                console.log("Keep-alive: Sending silent utterance.");
                const silentUtterance = new SpeechSynthesisUtterance('');
                silentUtterance.volume = 0; // Make it silent
                speechSynthesis.speak(silentUtterance);
            }
        }, 14000); // Every 14 seconds
    }

    // Function to stop the keep-alive interval
    function stopKeepAlive() {
        if (keepAliveInterval) {
            console.log("Stopping keep-alive interval.");
            clearInterval(keepAliveInterval);
            keepAliveInterval = null;
        }
    }

    // Voices might load asynchronously
    populateAndSelectVoice(); // Attempt initial load
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = populateAndSelectVoice;
    }
    
    // Ensure button and content exist
    if (!ttsButton || !postContent) {
        console.error('TTS button or content element not found.');
        if (ttsButton) ttsButton.style.display = 'none'; // Hide button if elements missing
        return;
    }
    
    // Define SVG Icons once
    const playIconSVG = `
      <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
        <path d="M8 5v14l11-7z"/>
      </svg>`;
    const stopIconSVG = `
      <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
        <path d="M6 6h12v12H6z"/>
      </svg>`;
      
    // Separate function to reset button state
    const resetButtonToPlay = () => {
      isSpeaking = false;
      ttsButton.innerHTML = playIconSVG; 
      ttsButton.setAttribute('aria-label', 'Listen to this post');
      ttsButton.setAttribute('title', 'Listen to this post');
      startKeepAlive(); // Restart keep-alive when speech ends/errors
    }

    // Separate function to initiate speech
    function startSpeaking() {
        const textToSpeak = postContent.textContent || postContent.innerText || '';
        if (textToSpeak.trim().length === 0) {
            console.warn('No text content found to speak.');
            resetButtonToPlay(); // Reset button if nothing to speak
            return;
        }
        
        utterance = new SpeechSynthesisUtterance(textToSpeak);
        
        if (preferredVoice && preferredVoice instanceof SpeechSynthesisVoice) {
          utterance.voice = preferredVoice;
          console.log("Using voice:", preferredVoice.name);
        } else {
          console.log("Using default voice.");
        }

        utterance.onstart = () => {
            stopKeepAlive(); // Stop keep-alive when real speech starts
            isSpeaking = true;
            ttsButton.innerHTML = stopIconSVG; 
            ttsButton.setAttribute('aria-label', 'Stop listening');
            ttsButton.setAttribute('title', 'Stop listening');
            console.log('Speech synthesis started.');
        };

        utterance.onend = () => {
          // onend fires for both completion and cancellation.
          // Only log finish if it wasn't cancelled by the user clicking stop.
          if (isSpeaking) { 
              console.log('Speech synthesis finished.');
          } else {
              console.log('Speech synthesis cancelled.');
          }
          resetButtonToPlay(); 
        };

        utterance.onerror = (event) => {
          console.error('Speech synthesis error:', event);
          resetButtonToPlay(); 
        };
        
        // Clear queue just before speaking
        speechSynthesis.cancel(); 
        speechSynthesis.speak(utterance);
    }

    ttsButton.addEventListener('click', () => {
      // 1. Check if voices are loaded
      if (!voicesLoaded) {
          console.warn("Voices not loaded yet. Please wait a moment and try again.");
          populateAndSelectVoice(); // Try loading again
          return; 
      }

      // 2. Handle stopping speech
      if (isSpeaking) {
        isSpeaking = false; // Manually set flag before cancel, as onend might be delayed
        speechSynthesis.cancel(); // Stop speaking (onend will call resetButtonToPlay)
        return; 
      }
      
      // 3. Check if synthesizer is stuck (Chrome quirk)
      if (speechSynthesis.speaking) {
          console.warn("Synthesizer is busy or stuck. Cancelling previous speech and retrying.");
          speechSynthesis.cancel();
          // Retry after a short delay to allow cancellation to complete
          setTimeout(startSpeaking, 150); // Increased delay slightly
          return;
      }

      // 4. If not speaking and synth is ready, start speaking
      startSpeaking(); 
    });

    // Optional: Stop speech synthesis and keep-alive when navigating away
    window.addEventListener('beforeunload', () => {
        stopKeepAlive();
        if (isSpeaking) {
            speechSynthesis.cancel();
        }
    });
  });
</script>
